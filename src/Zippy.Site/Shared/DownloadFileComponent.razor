@using Microsoft.AspNetCore.Components.Forms;
@using System.IO;
@using Zippy.ZipAnalysis.IO;

@inject IJSRuntime JS


@if (Headers != null && UploadedFile != null)
{
    <script>
        window.downloadFileFromStream = async (fileName, contentStreamReference) => {
            const arrayBuffer = await contentStreamReference.arrayBuffer();
            const blob = new Blob([arrayBuffer]);
            const url = URL.createObjectURL(blob);
            const anchorElement = document.createElement('a');
            anchorElement.href = url;
            anchorElement.download = fileName ?? '';
            anchorElement.click();
            anchorElement.remove();
            URL.revokeObjectURL(url);
        }
    </script>


    <button @onclick="DownloadFile">
        Download File
    </button>
}


@code {
    [Parameter]
    public IBrowserFile? UploadedFile{ get; set; }

    [Parameter]
    public IEnumerable<ZipHeaderBase>? Headers { get; set; }


    private async Task DownloadFile()
    {
        if (UploadedFile != null && Headers != null)
        {
            var zipStream = await CreateAlterZipStreamAsync(UploadedFile.OpenReadStream(), Headers);
            using var streamRef = new DotNetStreamReference(zipStream);
            await JS.InvokeVoidAsync("downloadFileFromStream", UploadedFile.Name, streamRef);
        }
    }

    private async Task<Stream> CreateAlterZipStreamAsync(Stream originalZip, IEnumerable<ZipHeaderBase> alteredHeaders)
    {
        var alteredStream = new MemoryStream(); // simple implementation, but takes whole file in memory
        await originalZip.CopyToAsync(alteredStream);

        foreach (var header in alteredHeaders)
        {
            alteredStream.Position = header.PositionFirstByte;
            header.WriteToStream(alteredStream);
        }
        alteredStream.Position = 0;

        return alteredStream;
    }
}
